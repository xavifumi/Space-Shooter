/* autogenerated by Processing revision 1293 on 2024-06-04 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class PracticaFinal extends PApplet {


/*  MATERIALS EMPRATS
TIPOGRAFIES:
https://www.dafont.com/es/game-2.font
https://www.dafont.com/es/crang.font
MUSICA:
https://juzek.itch.io/game-boy-music-loop-pack?download
ANIMACIO GALAXIA (adaptada a processing):
https://processing.org/examples/simpleparticlesystem.html
EFECTES DE SO:
https://freesound.org/people/marcuslee/
https://freesound.org/people/Ideacraft/sounds/345110/
https://freesound.org/people/Michel88/
https://freesound.org/people/SlykMrByches/sounds/55234/
https://freesound.org/people/MATRIXXX_/sounds/441225/
https://freesound.org/people/combine2005/sounds/488294/
https://freesound.org/people/Jace/sounds/19108/


*/


//per si de cas
//https://www.dafont.com/es/doomed.font
//https://www.dafont.com/es/pixelary.font

//import java.util.*;
//import controlP5.*;


int mode;
int frames = 30;
String[] llistaMusica = { "BattleMusic", "BossTheme", "Chase", "Cool", "Ruins"}; 
String[] llistaLaser = { "laser1", "laser2"};
String[] llistaMonstre = {"monstre1", "monstre2", "monstre3", "monstre4"};
int musica;
int score;
PFont fontTitol;
PFont fontCos;
Minim myMinim;
AudioPlayer music;



int[] moviment = {0, 0};
int[] posició = {width/2, height/2};
//int punts;
//int vides;
IntroScreen introScreen;
GameScreen gameScreen;
GameOver gameOver;
Player player;

//Maquina d'estats
final int TITOL = 1;
final int SELECT =2;
final int JOC = 3;
final int GAMEOVER = 4;

public void setup(){
  //fullScreen();
  /* size commented out by preprocessor */;
  myMinim = new Minim(this);
  music = myMinim.loadFile("/music/Tension.mp3");
  music.setGain(-6);
  fontTitol = createFont("/fonts/Crang.ttf", 128);
  fontCos = createFont("/fonts/Game-Font.ttf", 64); 
  frameRate (frames);
  mode = TITOL;
  introScreen = new IntroScreen();
  gameScreen = new GameScreen();
  gameOver = new GameOver();
}

public void draw(){

  switch(mode){
    case TITOL:
      introScreen.introScreen();
      break;
    case SELECT:
      //mainMenu.mainMenu();
      break;
    case JOC:
      gameScreen.gameScreen(); 
      break;
    case GAMEOVER:
      gameOver.overScreen();
      break;
  }
}

public void keyPressed(){
  if(mode == TITOL){
      introScreen.keyPressed();
    }
  if(mode == JOC){
    gameScreen.keyPressed();
  }
    if(mode == GAMEOVER){
    gameOver.keyPressed();
  }
}
public void keyReleased(){
  if(mode == JOC){
    gameScreen.keyReleased();
  }
}

public void mouseClicked(){
  if(mode == JOC){
    gameScreen.mouseClicked();
  }
}
class GameScreen {

  ArrayList<Enemic> enemics;
  ArrayList<Particle> particles;
  Galaxia galaxia = new Galaxia();
  StopWatch generador;
  int enemicsInicials;
  int llencador;
  int maximEnemics = 40;

  
  GameScreen(){
    inicialitza();
  }
  
  public void gameScreen(){
    //background(120);
    galaxia.display();
    ompleEnemics();
    if(generador.getRunTime()+ constrain(enemics.size(), 0, 14)>15 && enemics.size()<=maximEnemics){
      enemics.add(new Enemic(random(width), random(height)));
      generador.reset();
    }
    for (int i=0; i< player.bales.size(); i++){
      player.bales.get(i).display();
      player.bales.get(i).update();
      for (int j=0; j< enemics.size(); j++){
        Enemic e = enemics.get(j);
        if(enemics.get(j).pos.dist(player.bales.get(i).pos)<enemics.get(j).h/2){    
          e.monstreHit = myMinim.loadFile("/fx/"+llistaMonstre[PApplet.parseInt(random(llistaMonstre.length-1))]+".wav");
          e.monstreHit.setGain(-3);
          e.monstreHit.play();
          int c = color(0, 255, 0);
          e.duradaTintar = 255;
          e.colorTintar = c;
          e.tintar = true;
          e.dany();
          player.bales.get(i).destroy = true;
          c = color(0, 255, 0);
          PVector angle = new PVector(0,0);
          angle.x= -player.bales.get(i).velocity.x;
          angle.y= -player.bales.get(i).velocity.y;
          for(int k=0; k < random(2,5); k++){
            particles.add(new Particle(player.bales.get(i).pos, angle , c ));
          }
        }
      }
      if(player.bales.get(i).destroy){
        player.bales.remove(i);
      }
    }
    for (int i=0; i< enemics.size(); i++){
      Enemic e = enemics.get(i);
      //primer comprovem que no s'acostin massa entre ells els enemics!
      for (int j=0; j< enemics.size(); j++){
        float d = PVector.dist(e.pos, enemics.get(j).pos);
        //no comparem un enemic amb ell mateix!
        if ((d < 80) && i!=j) {
          PVector separa = new PVector(0,0);
          separa.x = e.pos.x - enemics.get(j).pos.x;
          separa.y = e.pos.y - enemics.get(j).pos.y;
          separa.normalize();
          e.pos.add(separa);
        } 
      }
      if(player.mort){
        e.estat = "pausa";
      }
      e.display();
      e.update();
      if(e.destroy){
        e.monstreHit = myMinim.loadFile("/fx/mortMonstre.mp3");
        e.monstreHit.play();
        enemics.remove(i);
        score += 1;
        //enemics.add(new Enemic(random(width), random(height)));
      }

    }

    player.update(mouseX, mouseY);
    player.display();
    for (int i = particles.size() - 1; i >= 0; i--) {
      Particle p = particles.get(i);
      p.update();
      p.display();
    if (p.destroy) {
      particles.remove(i);
    }
  }
  gui();
  //si buidem la pantalla es reomple, una mica més difícil.
  if (enemics.size() == 0){
    enemicsInicials++;
    llencador = 0;
    ompleEnemics();  
  }
  }
  
  public void dany(){
    player.invencible.reset();
    if(player.vida>0){
      player.vida -= 1;
    } else {
      player.mort = true;
      player.mort();
      
    }
  } 
  
  public void puntua(){
     score = score + 10;
  }
  
  public void keyPressed(){
 
  switch(keyCode){
    case LEFT:
      moviment[0] = -1;
      break;
    case RIGHT:
      moviment[0] = 1;
      break;
    case UP:
      moviment[1] = -1;
      break;
    case DOWN:
      moviment[1] = 1;
      break;
  }
  switch(key){
    case 'a':
      moviment[0] = -1;
      break;
    case 'd':
      moviment[0] = 1;
      break;
    case 'w':
      moviment[1] = -1;
      break;
    case 's':
      moviment[1] = 1;
      break;
  }

}
  public void keyReleased(){

    switch(keyCode){
      case LEFT:
      case RIGHT:
        moviment[0] = 0;
        break;
      case UP:
      case DOWN:
        moviment[1] = 0;
        break;
    }
      switch(key){
    case 'a':
    case 'd':
      moviment[0] = 0;
      break;
    case 'w':
    case 's':
      moviment[1] = 0;
      break;
    }
  }
  
  public void mouseClicked(){
    player.mouseClicked();
  }
  
  public void gui(){
    rectMode(CORNER);
    noFill();
    stroke(120);
    strokeWeight(2);
    rect(10, 10, 200, 30, 4);
    noStroke();
    fill(0, 255, 0);
    for (int i = 15; i<=36; i++ ){
      int from = color(0, 255, 0);
      int to = color(0, 100, 0);
      stroke(lerpColor(from, to, (i-14)*0.04f));
      strokeWeight(1);
      line(15, i,  PApplet.parseInt(map(player.vida, 0, 20, 15, 206)), i );
    }
    //rect(15, 15, map(player.vida, 0, 20, 0, 191), 21, 2 );
    textAlign(LEFT);
    textSize(30);
    fill(255);
    noStroke();
    textFont(fontCos);
    text("SCORE: " + score, 12, 70 );
    text("ENEMICS: " + enemics.size(), 12, 100);
    text("FPS: " + frameCount/(millis()/1000), 12, 130);
    //text("TEMPS: "+player.invencible.getRunTime(), 10, 600);
  }

  public void inicialitza(){
    generador = new StopWatch();
    player = new Player();
    enemics = new ArrayList<Enemic>();
    particles = new ArrayList<Particle>();
    score = 0;
    llencador = 0;
    enemicsInicials = 5;

  }
  
  //generar enemics si la pantalla es buida
  public void ompleEnemics(){
      if(generador.getRunTime()>llencador && enemics.size() < enemicsInicials && enemics.size()<=maximEnemics){
        enemics.add(new Enemic(random(width), random(height)));
      llencador = PApplet.parseInt((float)generador.getRunTime())+1;
    } 
  }

}


  
class Bala {
  int dany;
  PVector pos;
  float angle;
  boolean destroy;
  PVector velocity;

  // Constructor que toma la posición y el ángulo del jugador
  Bala(PVector playerPos, float playerAngle) {
    dany = 1;
    pos = playerPos.copy();
    angle = playerAngle;
    destroy = false;
    // Calcular la velocitat en base a l'angle
    float speed = 10;
    velocity = new PVector(cos(angle) * speed, sin(angle) * speed);
  }

  public void display() {
    pushMatrix();
      translate(pos.x, pos.y); 
      noStroke();
      //La bala té 3 cercles de diferents opacitats per fingir una estela
      fill(255, 120, 0, 80);
      circle(-velocity.x*2, -velocity.y*2, 10);
      fill(255, 120, 0, 160);
      circle(-velocity.x, -velocity.y, 10);
      fill(255);
      strokeWeight(5);
      stroke(255, 120, 0);
      circle(0, 0, 10);  
    popMatrix();
    noStroke();
  }

  public void update() {
    //actualitzem posició i si surt fora pantalla destruim
    pos.add(velocity);
    if (pos.x >width || pos.x<0 || pos.y >height || pos.y<0){
    destroy = true;
    }
  }
} // Fi Objecte BALA

class Enemic {
  //propietats
  PVector pos, velocity;
  PImage avatar;
  float w, h, maxSpeed;
  float angle = 0.0f;
  int vida;
  ArrayList<Bala> bales;
  boolean destroy, fxPlay;
  String estat;
  boolean tintar = false;
  int colorTintar;
  float duradaTintar = 0;
  float heightAnim, widthAnim;
  StopWatch cronoAparicio;
  AudioPlayer monstreFX;
  AudioPlayer monstreHit;
  AudioPlayer cop;
  
  //inicialitzem
  Enemic(float posX, float posY){
    avatar = loadImage("/sprites/Monstre"+ PApplet.parseInt(random(0,3))+"00.png");
    vida = 5;
    bales = new ArrayList<Bala>();
    pos = new PVector(posX, posY);
    w = avatar.width;
    h = avatar.height;
    maxSpeed = 3;
    destroy = false;
    fxPlay = false;
    estat = "aparicio";
    // Calcular la velocidad en base al ángulo
    velocity = new PVector();
    cronoAparicio = new StopWatch();
    widthAnim = 0;
    heightAnim = avatar.height*2;
    monstreFX = myMinim.loadFile("/fx/teleport.wav");
    monstreFX.setGain(-9);
    cop = myMinim.loadFile("/fx/cop.wav");
    cop.setGain(-6);
  }
  
   public void display() {
    pushMatrix();
    translate(pos.x, pos.y);
    rotate(angle);
    fill(0);
    stroke(255, 0, 0);
    strokeWeight(2);
    rectMode(CENTER);
    //rect(0, 0, h, w);  // Dibujar la bala en la posición (0, 0) relativa
    //image(avatar, 0, 0, avatar.width, avatar.height);
        image(avatar, 0, 0, widthAnim, heightAnim);
        if(tintar){
          tint(colorTintar, duradaTintar);
          duradaTintar -= 255/20;
        }
        image(avatar, 0, 0, widthAnim, heightAnim);
        noTint();
    rectMode(CORNER);
    popMatrix();
    noStroke();
  }

  public void update() {
    //flock(gameScreen.enemics);
    switch(estat){
      case "atac":
        atac();
        break;
      case "aparicio":
        aparicio();
        break;
      case "destruccio":
        destruccio();
        break;
      case "pausa":
        pausa();
        break;
    }
  }
  
  public void aparicio(){
    if (!fxPlay){
      monstreFX.play();
      fxPlay = true;
    }

      if (widthAnim < avatar.width){
        widthAnim+=5;
        if (heightAnim > avatar.height){
          heightAnim-=5;
        }
      } else {
        widthAnim = avatar.width;
        heightAnim = avatar.height;
        estat = "atac";
        fxPlay= false;
      }
  
  }
  
  public void atac(){
    //Si el jugador és lluny ens hi acostem
    //Primer calculem el vector de direcció
    
    if(player.pos.dist(pos) > h){  
      velocity.x = pos.x-player.pos.x;
      velocity.y = pos.y-player.pos.y;
    }
    if(!cop.isPlaying()){
    cop.rewind();
    }
    //ajustem a la velocitat del eniemic i modifiquem posició
    velocity.normalize();
    velocity.mult(maxSpeed);
    pos.sub(velocity);
    //Si toquem el jugador quan no és invencible li fem mal
    if(player.pos.dist(pos) <= h && player.invencible.getRunTime()>player.duradaInvencible){
      cop.play();
      gameScreen.dany();
      //Tintem el jugador de color vermell per indicar el dany
      int c = color(255, 0, 0);
      player.duradaTintar = 255;
      player.colorTintar = c;
      player.tintar = true;
      //creem particules efecte "sang"
      for(int k=0; k < random(2,5); k++){
        gameScreen.particles.add(new Particle(player.pos, velocity , c ));
      }
    }
  }
 
  /*
  void applyForce(PVector force) {
    // We could add mass here if we want A = F / M
    velocity.add(force);
  }
  
  void flock(ArrayList<Enemic> enemics) {
    PVector sep = separate(enemics);   // Separation
  // Cohesion
    // Arbitrarily weight these forces
    sep.mult(1.5);
    // Add the force vectors to acceleration
    applyForce(sep);
  }

  
  PVector separate (ArrayList<Enemic> enemics) {
    float desiredseparation = 25.0f;
    PVector steer = new PVector(0, 0, 0);
    int count = 0;
    // For every boid in the system, check if it's too close
    for (Enemic other : enemics) {
      float d = PVector.dist(pos, other.pos);
      // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
      if ((d > 0) && (d < desiredseparation)) {
        print("it's flocking!\n");
        // Calculate vector pointing away from neighbor
        PVector diff = PVector.sub(pos, other.pos);
        diff.normalize();
        diff.div(d);        // Weight by distance
        steer.add(diff);
        count++;            // Keep track of how many
      }
    }
    // Average -- divide by how many
    if (count > 0) {
      steer.div((float)count);
    }

    // As long as the vector is greater than 0
    if (steer.mag() > 0) {
      // First two lines of code below could be condensed with new PVector setMag() method
      // Not using this method until Processing.js catches up
      // steer.setMag(maxspeed);

      // Implement Reynolds: Steering = Desired - Velocity
      steer.normalize();
      steer.mult(5);
      steer.sub(velocity);
      steer.limit(10);
    }
    return steer;
  }*/
  
  public void destruccio(){
      monstreFX.play();
      fxPlay = true;

      if (widthAnim > 0){
        widthAnim-=5;
        if (heightAnim < avatar.height*2){
          heightAnim+=5;
        }
      } else {
        widthAnim = 0;
        heightAnim = avatar.height*2;
        destroy = true;
      }
  }
  
  public void dany(){
      if(vida>0){
      vida -= 1;
    } else {
      estat = "destruccio";
    }
  }
  
  public void pausa(){
  }
} //Fi Objecte ENEMIC

class Particle {
  PVector position;
  PVector velocity;
  float fadeOut;
  int tonalitat;
  boolean destroy;

  Particle(PVector XY, PVector direction, int to) {
    position = XY.copy();
    float angle = direction.heading() + random(-0.4f, 0.4f);
    velocity = PVector.fromAngle(angle);
    velocity.setMag(random(10,30));
    tonalitat = to;
    fadeOut = 255.0f;
    destroy = false;
  }

  public void update() {
    position.add(velocity.mult(0.8f));
    if(fadeOut > 0.0f){
      fadeOut -= 255.0f / 10.0f; 
    } else{
      destroy = true;
    }
  }

  public void display() {
    noStroke();
    fill(tonalitat, fadeOut);
    rect(position.x, position.y, 10, 10);
  }

}
class IntroScreen {
  Galaxia galaxia = new Galaxia();
  int fadeValue;
  boolean fade;
  
    IntroScreen(){
      fadeValue = 254;
      fade =true;
      music.play();
    }
  public void introScreen() {
    //music.play();    
    galaxia.display();
    //background(10);
    fill(255, 0, 255);
    //textSize(128);
    textFont(fontTitol);
    textAlign(CENTER, CENTER);
    text("PRÀCTICA\nFINAL", width/2, (height/3));
    //Faren que la opacitat oscili per a cridar l'atenció sobre el text:
    if(fade){
      fadeValue -= 10;
    } else {
      fadeValue += 10;
    } 
    fill(fadeValue);
    textFont(fontCos);
    text("prem espai per iniciar", width/2, (height/3)*2);
    if (fadeValue < 120 || fadeValue >244){
      fade = !fade;
    }
    fill(255);
    text("moviment amb WASD apuntar i disparar amb ratoli", width/2 , height-30);
  }
  
  public void keyPressed(){
    if(key == ' '){
      music.pause();
      music = myMinim.loadFile("/music/"+ llistaMusica[PApplet.parseInt(random(llistaMusica.length))] +".mp3");  
      music.setGain(-12);
      music.loop();
      mode = JOC;
    }
  }
}

class GameOver {
  
  public void overScreen() {
    background(10);
    fill(255, 0, 0);
    textFont(fontTitol);
    textAlign(CENTER, CENTER);
    text("HAS\nPERDUT", width/2, (height/3));
    fill(255);
    textFont(fontCos);
    text("has aconseguit:\n" + score + " punts", width/2, (height/3)*2);
    textAlign(LEFT);
    text("UOC - Grau Multimedia", 30, height-70);
    text("Xavi Fumado - Juny 2024", 30, height-40);
  }
  
  public void keyPressed(){
    if(key == ' '){
      //gameScreen = new Gamescreen();
      gameScreen.inicialitza();
      mode = JOC;
    }
  }
}
class Player {
  //propietats
  PVector pos, speed, actualSpeed, correccio, rotMotor;
  PImage avatar, fxMotor, explosio;
  int DIM = 4;
  PImage[] exploSprites = new PImage[DIM*DIM];
  float w, h;
  float maxSpeed, accel, playerRot, duradaInvencible, fadeValue;
  float angle = 0.0f;
  int vida, framesFi;
  ArrayList<Bala> bales;
  StopWatch invencible;
  boolean tintar, motor, mort, fiPartida;
  int colorTintar;
  float duradaTintar = 0;
  float timerFinal;
  AudioPlayer spaceship;
  AudioPlayer shoot;
  
  //inicialitzem
  Player(){
    avatar = loadImage("/sprites/ship.png");
    fxMotor = loadImage("/sprites/effect_yellowB.png");
    explosio = loadImage("/sprites/explosio.png");
    spaceship = myMinim.loadFile("/fx/spaceship.wav");
    spaceship.setGain(-6);
    //generem els sprites de l'explosió emprant un spritesheet
    int explW = explosio.width/DIM;
    int explH = explosio.height/DIM;
    for (int i=0; i<exploSprites.length; i++) {
      int x = i%DIM*explW;
      int y = i/DIM*explH;
      exploSprites[i] = explosio.get(x, y, explW, explH);
      fiPartida = false;
      timerFinal = 50;
    }
    vida = 20;
    bales = new ArrayList<Bala>();
    pos = new PVector(width/2, height/2);
    speed = new PVector(0, 0);
    actualSpeed = new PVector(0, 0);
    correccio = new PVector(0, 0);
    rotMotor = new PVector(0,0);
    w = avatar.width;
    h = avatar.height;
    maxSpeed = accel =  10;
    playerRot = 0;
    invencible = new StopWatch();
    duradaInvencible = 0.5f;
    motor = false;
    mort = false;
    fadeValue = 120;
  }
  
  //si el jugador és viu es pot moure:
  public void update(int mx, int my){  
    if(!mort){
      if (moviment[0]<0) {
        speed.x = -1;
      }
      if(moviment[0]>0 ){
        speed.x = +1;
      }
      if (moviment[1]<0) {
        speed.y = -1;
      }
      if(moviment[1]>0){
        speed.y = +1;
      }
      if(moviment[0] == 0){
        speed.x = 0;
      }
      if(moviment[1] == 0){
        speed.y = 0;
      }
    } 
    //Per a fer que no es mogui més ràpid en diagonal pel teorema de pitàgores x2 + y2 = diagonal2 = 1.4
    //normalitzem el vector primer i després el multipliquem per la velocitat.
    speed.normalize();
    speed.mult(maxSpeed);
    //fem que la velocitat vagi canviant poc a poc a la que serà la definitiva fingint una fricció o resistència
    //correccio.set(speed.sub(actualSpeed));
    correccio.set(speed.x - actualSpeed.x, speed.y - actualSpeed.y);
    actualSpeed.x += correccio.x*0.1f;
    actualSpeed.y += correccio.y*0.1f;
    player.pos.x += actualSpeed.x;
    player.pos.y += actualSpeed.y;
    player.playerRot = actualSpeed.heading();
    //Que no surti dels marges de la pantalla
    if(player.pos.x > width){player.pos.x = width;}
    if(player.pos.x < 0){player.pos.x = 0;}
    if(player.pos.y > height){player.pos.y = height;}
    if(player.pos.y < 0){player.pos.y = 0;}
    angle = atan2(my-player.pos.y, mx-player.pos.x);
  }
  
  public void display(){
    //sprite del jugador
    fill(255);
    imageMode(CENTER);
    ellipseMode(CENTER);
    pushMatrix();
    //Per si de cas, limitem les posicions del jugador dins la pantalla     
      translate(constrain(player.pos.x, 0, width), constrain(player.pos.y, 0, height)); 
        //l'angle de la flama ha de intentar corregir l'angle de la nau perquè arribi a ser el que li indiquem.
        pushMatrix();      
          rotMotor.x = speed.x - correccio.x;
          rotMotor.y = speed.y - correccio.y;
          rotate(rotMotor.heading());
          //animem l'oscilació de transparència de la flama
          if(moviment[0]!=0 || moviment[1]!=0){
            if(!spaceship.isPlaying())
              spaceship.loop();
            if(motor){
                fadeValue -= 20;
            } else {
                fadeValue += 20;
            } 
            if (fadeValue < 120 || fadeValue >244){
              motor = !motor;
            }
            tint(255, fadeValue);
            image(fxMotor, -avatar.width+fxMotor.width/2, 0, random(fxMotor.width/2, fxMotor.width), fxMotor.height);
            noTint();
          } else {
          spaceship.pause();
          }
        popMatrix();
      pushMatrix();
      //sprite principal, el carreguem 2 cops un per efecte de tintar en rebre dany
        rotate(playerRot);    
        image(avatar, 0, 0, avatar.width, avatar.height);
        if(tintar){
          tint(colorTintar, duradaTintar);
          duradaTintar -= 255/20;
        }
        image(avatar, 0, 0, avatar.width, avatar.height);
        noTint();
        if(mort && !fiPartida){
          //triger de fi de partida que volem executar només un cop
          music.shiftGain(-12, -100, 3000);   
          spaceship = myMinim.loadFile("/fx/explosio.wav");
          fiPartida = true;
        } else if (mort){
          spaceship.play();
          mort();    
        }
      popMatrix(); 
     //cursor del canó
      stroke(0, 0, 255);
      strokeWeight(4);
      rotate(angle);
      translate(100, 0);
      rotate(-angle);
      fill(0);
      line(-7, 0, 7, 0);
      line(0, -7, 0, 7);
      noStroke();
    popMatrix(); //1
    imageMode(CORNER);
    ellipseMode(CORNER);
    
  }
  //si el jugador és viu pot disparar:
  public void mouseClicked(){
    if (!mort){
      shoot = myMinim.loadFile("/fx/"+ llistaLaser[PApplet.parseInt(random(2))] +".wav");
      shoot.setGain(-6);
      shoot.play();
      player.bales.add(new Bala(player.pos, angle));
    }
  }
  
  //seqüència de mort, activem compte enrere i animació d'explosions
  public void mort(){ 
      if(timerFinal > 0){
        image(exploSprites[frameCount%exploSprites.length], 0, 0, 96, 96);
        timerFinal--;
      }else{ // en acabar temporitzador canviem a GAMEOVER
        music.pause();
        music = myMinim.loadFile("/music/Throne.mp3");  
        music.setGain(-9);
        music.play(); 
        mode = GAMEOVER;
      }
  }
  
} //Fi Player
//Objecgte Temporitzador, codi agafat de StackOverflow
public class StopWatch {
  private long currTime;
  private long lastTime;
  private long lapTime;
  private long startTime;

  public StopWatch() {
    reset();
  }

  // Resetejar el temporitzador
  public void reset() {
    currTime = lastTime = startTime = System.nanoTime();
    lapTime = 0;
  }

  // Temps des de l'últim reset()
  public double getRunTime() {
    double rt = 1.0E-9f * (System.nanoTime() - startTime);
    return rt;
  }

  // Temps transcorregut des de l'últim cop que s'ha cridat aquesta funció
  public double getElapsedTime() {
    currTime = System.nanoTime();
    lapTime = currTime - lastTime;
    lastTime = currTime;
    return 1.0E-9f * lapTime;
  }
}

class Galaxia{
  int worldSize = width;
  int nStars = 600; 
  float maxS = 4.0f;
  float[] s = new float[nStars];
  float[] x = new float[nStars];
  float[] y = new float[nStars];
  float angle, speed;
  float speedX, speedY;
  
  Galaxia(){
    background(0);
    float t = (1.0f - 1.0f / (maxS * maxS * maxS)) / (nStars - 1);
    for (int i = 0; i < nStars; i++) {
      s[i] = pow(1.0f / (1.0f - t * i), 0.33333333f);
      x[i] = random(worldSize + 8.0f * s[i]);
      y[i] = random(worldSize + 8.0f * s[i]);
    }
  
    angle = -0.2f;
    speed = 8.0f / maxS;
  }
  
  public void display(){
    background(0, 128);
    speedX = speed * cos(angle);
    speedY = speed * sin(angle);
   
    for (int i = 0; i < nStars; i++) {
      if (x[i] < worldSize + 2 * s[i] && y[i] < worldSize + 2 * s[i]) {
        strokeWeight(s[i]);
        stroke(map(s[i], 1.0f, maxS, 128, 255));
        line(x[i] - s[i], y[i] - s[i], 
             x[i] - s[i] + speedX * (s[i] - 0.99f), y[i] - s[i] + speedY * (s[i] - 0.99f));
      }
      float wrap = worldSize + 8.0f * s[i];
      x[i] = (x[i] - speedX * (s[i] - 0.99f) + wrap) % wrap;
      y[i] = (y[i] - speedY * (s[i] - 0.99f) + wrap) % wrap;
    }
  }
}


  public void settings() { size(1024, 768); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "PracticaFinal" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
